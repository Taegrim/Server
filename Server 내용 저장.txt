------------------------------------------------------------
// Thread의 생성 및 예시
#include "pch.h"
#include <iostream>
#include "CorePch.h"

#include <thread>

void HelloThread()
{
    cout << "Hello Thread " << endl;
}

void HelloThread2(int32 num)
{
    cout << num << endl;
}

int main()
{
    std::thread t(HelloThread);
    // thread 로 HelloThread를 실행 시 독립적으로 실행 됨
    // thread는 호출가능 타입을 호출함

    cout << "Hello Main" << endl;


    //int32 count = t.hardware_concurrency(); // CPU 코어 개수가 몇개인지 알려줌
                                              // 동시에 실행 가능한 쓰레드 개수를 의미함
    //auto id = t.get_id();                   // 쓰레드마다 id를 알려줌, 쓰레드를 구분하는데 이용
                                              // 쓰레드 객체에 함수호출이 될 때 id가 할당 됨
    //t.detach();                             // thread 객체에서 실제 쓰레드를 분리
                                              // 분리 시 thread 객체의 상태, 정보 추출이 불가능
    //t.joinable();                           // 쓰레드가 연동되어 있는지를 판별
                                              // 쓰레드 객체의 생성과 함수 호출을 따로할 때 사용

    t.join();
    // join 함수로 thread 객체가 실행한 함수가 끝날때까지 기다리도록 함

    int32 count = t.hardware_concurrency();
    cout << "코어 개수 : " << count << endl;


    // 벡터에 쓰레드를 담아 이용할 경우 생성과 함수 호출을 달리하는 경우가 생김
    // ★쓰레드는 병렬로 실행되기 때문에 어느것이 먼저 호출될지는 알 수 없음
    vector<std::thread> v;

    for (int32 i = 0; i < 10; ++i)
        v.push_back(std::thread(HelloThread2, i));

    for (std::thread& th : v)
        if (th.joinable())
            th.join();

    cout << "Hello Main" << endl;
}

------------------------------------------------------------

------------------------------------------------------------
﻿// Atomic
// 공유 데이터 사용 시 발생하는 문제점들을 알아볼 것

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include "save.h"

int32 sum = 0;

void Add()
{
    for (int32 i = 0; i < 100'0000; ++i)
        ++sum;
}

void Sub()
{
    for (int32 i = 0; i < 100'0000; ++i)
        --sum;
}

int main()
{
    Add();
    Sub();
    cout << sum << endl;

    std::thread t1(Add);
    std::thread t2(Sub);

    t1.join();
    t2.join();
    cout << sum << endl;
    // thread로 공유 데이터의 덧셈, 뺄셈 수행 시 sum의 값은 할때마다 다른 값을 출력함
    // CPU 는 데이터를 변경할 때 해당 메모리의 값을 가져오고 변경한 다음 이 값을 다시 메모리에 씀
    
    // thread 2개가 덧셈 뺄셈함수를 호출할 경우 함수에서 같은 데이터를 동시에 접근한다
    // 만약 Add, Sub가 동시에 실행되면 각각 0이라는 값을 가져와서 연산을 수행한다
    // 조금이라도 더 늦은 함수의 결과에 의해 값이 써진다
    // 즉, 공유 데이터의 경우 다른 함수에서 연산이 끝나기 전에 데이터를 가져오므로 문제가 발생한다.


    save("GameServer.cpp");
}
------------------------------------------------------------

------------------------------------------------------------
﻿// Atomic
// 공유 데이터 사용 시 발생하는 문제점들을 알아볼 것

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include "save.h"

// atomic : All - Or - Nothing
// 예시 : DB
// A라는 유저 인벤에서 집행검 빼고
// B라는 유저 인벤에서 집행검을 추가
// 이 경우 한 경우만 일어나면 안되기 때문에 atomic 하게 일어나야함

// atomic을 이용하면 쓰레드간 경합이 발생하면 한 쓰레드가 데이터에 접근하면
// 다른 쓰레드는 잠시 대기하도록 함 (대기하도록 하는 주체는 CPU)
// -> 잠시 대기하도록 하기 때문에 실행 시간이 늦어지는 문제가 있음

atomic<int32> sum = 0;

void Add()
{
    for (int32 i = 0; i < 100'0000; ++i)
        sum.fetch_add(1);
        //sum++
}

void Sub()
{
    for (int32 i = 0; i < 100'0000; ++i)
        sum.fetch_add(-1);
        //--sum;
}

int main()
{
    Add();
    Sub();
    cout << sum << endl;

    std::thread t1(Add);
    std::thread t2(Sub);

    t1.join();
    t2.join();
    cout << sum << endl;

    save("GameServer.cpp");
}
------------------------------------------------------------

------------------------------------------------------------
﻿// Lock (mutex)
// 공유 데이터 처리 시 해결 방법

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include "save.h"

// 벡터는 capacity가 가득차면 새로운 크기만큼 메모리를 할당하고 기존의 메모리를 삭제하는 구조
// capacity가 가득 찼을 때 쓰레드가 동시에 vector에 접근하면 나중에 실행되는 쓰레드는 삭제된 메모리를 이용함

// reserve로 용량을 확보하고 하더라도 멀티쓰레드에선 동시에 벡터에 접근할 경우
// 이전에 벡터에서 새로운 인덱스에 작성한 것을 덮어쓰는 경우가 발생함 -> 데이터의 유실 발생

vector<int32> v;

void Push()
{
	for (int32 i = 0; i < 1'0000; ++i)
		v.push_back(i);
}

int main()
{
	v.reserve(20000);

	std::thread t1(Push);
	std::thread t2(Push);
	t1.join();
	t2.join();

	cout << v.size() << endl;

   save("GameServer.cpp");
}
------------------------------------------------------------
﻿// ------------------------------------------------------------------------------------------------------------------------
// Lock (mutex)
// 공유 데이터 처리 시 해결 방법
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <mutex>
#include "save.h"

vector<int32> v;
mutex m;
// Mutual Exclusive (상호 배타적)
// atomic 처럼 딜레이가 있으므로 동작이 느림

// 유의점 1. 재귀적으로 lock 사용시 recursive_mutex 사용 (일반적인 mutex는 여러번 lock 불가능)
// 유의점 2. lock 이용 시 unlock을 반드시 해야함 (예외 처리를 할 경우 unlock이 걸리는지에 유의)
//           -> 일일히 unlock을 하면 복잡함, 빠지는 부분이 있을 수 있음 
//           -> RAII 방식으로 처리


void Push()
{
	for (int32 i = 0; i < 1'0000; ++i) {
		m.lock();
		v.push_back(i);

		m.unlock();
	}
}

int main()
{
	std::thread t1(Push);
	std::thread t2(Push);
	t1.join();
	t2.join();

	cout << v.size() << endl;

   save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Lock (mutex)
// 공유 데이터 처리 시 해결 방법
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <mutex>
#include "save.h"

vector<int32> v;
mutex m;
// Mutual Exclusive (상호 배타적)
// atomic 처럼 딜레이가 있으므로 동작이 느림

// 유의점 1. 재귀적으로 lock 사용시 recursive_mutex 사용 (일반적인 mutex는 여러번 lock 불가능)
// 유의점 2. lock 이용 시 unlock을 반드시 해야함 (예외 처리를 할 경우 unlock이 걸리는지에 유의)
//           -> 일일히 unlock을 하면 복잡함, 빠지는 부분이 있을 수 있음 
//           -> RAII 방식으로 처리
// 유의점 3. lock을 거는 범위에 따라 실행이 완전히 달라질 수 있음

// RAII (Resource Aquisition Is Initialization)

template<typename T>
class LockGuard {
public:
	LockGuard(T& m) {
		_mutex = &m;
		_mutex->lock();
	}

	~LockGuard() { _mutex->unlock(); }

private:
	T* _mutex;
};
// 객체 생성에 대한 부담이 있으나 lock, unlock을 수동으로 하는것보다 안정적임

void Push()
{
	// for문 전에 lock을 걸면 Push함수가 끝나야 다른 쓰레드가 접근할 수 있어짐
	for (int32 i = 0; i < 1'0000; ++i) {
		//LockGuard<std::mutex> lockGuard(m);
		//std::lock_guard<std::mutex> lockGuard(m);		// 표준 lock_guard

		std::unique_lock<std::mutex> uniqueLock(m, std::defer_lock);
		// std::defer_lock 으로 바로 잠그지 않고 lock() 호출 시 잠그도록 할 수 있음

		uniqueLock.lock();

		if (5000 == i)
			break;

		v.push_back(i);
	}
}

int main()
{
	std::thread t1(Push);
	std::thread t2(Push);
	t1.join();
	t2.join();

	cout << v.size() << endl;

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Dead Lock
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"
#include "AccountManager.h"
#include "UserManager.h"

void Func1()
{
	for (int32 i = 0; i < 1000; ++i)
		UserManager::Instance()->ProcessSave();
}

void Func2()
{
	for (int32 i = 0; i < 1000; ++i)
		AccountManager::Instance()->ProcessLogin();
}

int main()
{
	std::thread t1(Func1);
	std::thread t2(Func2);

	t1.join();
	t2.join();

	cout << "Done" << endl;
	// mutex가 여러개일 때 번호를 지정하여 번호에 따라 순서를 맞추면 어느정도는 해결된다

	mutex m1;
	mutex m2;

	std::lock(m1, m2);
	// std::lock을 이용하면 내부적으로 m1, m2에 순서를 부여하여 lock을 함

	lock_guard<mutex> g1(m1, std::adopt_lock);
	lock_guard<mutex> g1(m2, std::adopt_lock);
	// adopt_lock : 이미 lock된 상태니까, 나중에 소멸될 때 풀어주도록 함

	// lock을 Graph 형식으로 구성하여 사이클이 발생하는지를 추적하여 해결할 수 있음


	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Spin Lock - Lock의 구현 이론
// 
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"

// 이 SpinLock 클래스는 Lock이 되어있는지를 확인하는 부분과 Lock을 거는 부분이 분리되어 있기 때문에
// 두개 이상의 쓰레드가 동시에 사용을 하면 서로 Lock을 걸 수 있다는 문제가 있음
class SpinLock 
{
public:
	void lock() {
		// volatile 을 사용하지 않으면 컴파일러는
		// while 문의 조건이 true이므로 매번마다 while문의 조건을 체크하지 않음
		while (locked) {

		}
		locked = true;
	}

	void unlock() {
		locked = false;
	}

private:
	volatile bool locked = false;
	// volatile 은 컴파일러에게 최적화 하지 않도록 명시하는 것
};

int32 sum = 0;
mutex m;
SpinLock spinLock;

void Add()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum++;
	}
}

void Sub()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum--;
	}
}

int main()
{
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Spin Lock - Lock의 구현 이론
// 
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"

// SpinLock 은 두 쓰레드가 경합이 발생하면 한쓰레드는 무한히 while문을 체크함
// 따라서 다른 쓰레드가 금방 unlock을 하지 않는다면 CPU점유율이 높아진다(CPU의 낭비)는 단점이 있음
class SpinLock 
{
public:
	void lock() {
		// CAS (Compare-And-Swap) 
		bool expected = false;
		bool desired = true;

		// CAS 의사코드 - 아래 코드를 한번에 실행하는 것
		/*if (locked == expected) {
			expected = locked;
			locked = desired;
			return true;
		}
		else {
			expected = locked;
			return false;
		}*/

		while (!locked.compare_exchange_strong(expected, desired)) {
			expected = false;
		}
		locked = true;
	}

	void unlock() {
		locked.store(false);
	}

private:
	atomic<bool> locked = false;
};

int32 sum = 0;
SpinLock spinLock;

void Add()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum++;
	}
}

void Sub()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum--;
	}
}

int main()
{
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Sleep - Lock의 구현 이론
// 
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"

class SpinLock 
{
public:
	void lock() {
		bool expected = false;
		bool desired = true;

		while (!locked.compare_exchange_strong(expected, desired)) {
			expected = false;
			//this_thread::sleep_for(std::chrono::milliseconds(100));
			this_thread::sleep_for(0ms);
			//this_thread::yield();
			// yield 는 다른 프로그램에 time slice를 넘기는 함수
		}
	}

	void unlock() {
		locked.store(false);
	}

private:
	atomic<bool> locked = false;
};

int32 sum = 0;
SpinLock spinLock;

void Add()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum++;
	}
}

void Sub()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum--;
	}
}

int main()
{
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Event - Lock의 구현 이론
// 
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"
#include <windows.h>

mutex m;
queue<int32> q;
HANDLE handle;

void Producer()
{
	while (true) {
		{
			unique_lock<mutex> lock(m);
			q.push(100);
		}

		::SetEvent(handle);
		// 이벤트의 상태를 Signal로 바꿈
		this_thread::sleep_for(100ms);
	}
}

void Consumer()
{
	while (true) {
		::WaitForSingleObject(handle, INFINITE);
		// handle 에 해당하는 이벤트가 발생할 때까지 INFINITE 만큼 대기함
		// Event을 Auto로 해두었기 때문에 Non-Signal 로 자동으로 변경함
		// ::ResetEvent(handle);

		unique_lock<mutex> lock(m);
		if (!q.empty()) {
			int32 data = q.front();
			q.pop();
			cout << data << endl;
		}
	}
}

int main()
{
	save("GameServer.cpp");

	// 커널 오브젝트
	// Usage Count
	// Signal / Non-Signal (켜짐/꺼짐) - bool
	// Auto / Manual - bool
	// 보안속성, 수동(true)/자동(flase) 리셋, 초기상태, 이름
	handle = ::CreateEvent(NULL, false, false, NULL);

	thread t1(Producer);
	thread t2(Consumer);

	t1.join();
	t2.join();

	::CloseHandle(handle);

}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Condition Variable - 쓰레드의 대기와 호출
// 실제 사용 사례 - 클라이언트에서 패킷을 보내면 서버에선 패킷이 있을때에만
// 확인하고 패킷을 꺼내 사용하는 방식으로 이용할 수 있다
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"

mutex m;
queue<int32> q;
condition_variable cv;
// condition_variable 은 User-Level Object (커널 오브젝트X)
// 커널 오브젝트이므로 다른 프로그램들과 동기화 할 수 없음

void Producer()
{
	while (true) {
		// 1) Lock 잡기
		// 2) 공유 변수 값 수정
		// 3) Lock 해제
		// 4) 조건변수 통해 다른 쓰레드에게 통지

		{
			unique_lock<mutex> lock(m);
			q.push(100);
		}
		// 지역변수를 통해 lock을 걸고 값을 수정했으면 빠져나올 때 lock을 해제하기 위해
		// while문에서 지역변수를 설정함

		cv.notify_one();	// wait중인 쓰레드가 있으면 해당하는 1개의 쓰레드를 깨움
		// notify_all 은 모든 쓰레드에게 통지
		
		// 락을 풀어준 뒤 다른 쓰레드에 통지하는 것이 일반적임
	}
}

void Consumer()
{
	while (true) {
		unique_lock<mutex> lock(m);
		cv.wait(lock, []() { return !q.empty(); });
		// 1) Lock 잡기
		// 2) 조건 확인
		//    만족O -> 빠져나와서 코드 진행
		//    만족X -> Lock을 풀어주고 대기 상태로 전환

		// notify_one을 했으면 항상 조건식을 만족하는 것이 아닌가?
		// Squrious WakeUp 문제
		// 생산부분에서 Lock을 잡고 풀어주는 것과 notify_one 호출은 분리되었기 떄문에
		// 이 사이에 데이터의 변경이 발생할 수 있기 때문에 cv.wait 에서 조건을 확인한다
		// -> notify_one 할때 lock을 잡아주는 것이 아니기 떄문
		
		int32 data = q.front();
		q.pop();
		cout << q.size() << endl;
	}
}

int main()
{
	save("GameServer.cpp");

	thread t1(Producer);
	thread t2(Consumer);

	t1.join();
	t2.join();
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Future
// 단발성 이벤트 호출
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include <future>
#include "save.h"

int64 Caculate()
{
	int64 sum = 0;

	for (int32 i = 0; i < 100'000; ++i)
		sum += i;

	return sum;
}

int main()
{
	// 동기(synchronous) 실행
	/*int64 sum = Caculate();
	cout << sum << endl;*/

	{
		// async 의 첫번째 인자
		// 1) deferred -> lazy evaluation 지연실행 (멀티 쓰레드는 아님)
		// 2) async -> 별도의 쓰레드를 만들어 실행
		//             쓰레드를 직접 생성하는 것보다 간편함
		// 3) deferred | async -> 둘 중 알아서 선택

		std::future<int64> future = std::async(std::launch::async, Caculate);
		// 클라이언트가 서버로 요청을 보내도 서버가 다른일을 하느라 바쁜 경우
		// 지연실행을 할 수 있음

		int64 sum = future.get(); // 결과물이 필요할 때 get으로 호출
								  // 결과물이 나올때까지 잠시 기다렸다가 결과물을 가져온다
		cout << sum << endl;

		class Knight {
		public:
			int64 GetHp() { return 100; }
		};

		Knight knight;
		std::future<int64> future2 = std::async(std::launch::async, &Knight::GetHp, knight);	// knight.GetHp();
	}

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Future
// mutex, condition_variable 까지 가지 않고 단순한 작업을 처리할 수 있음
// 일회성 이벤트에 유용함
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include <future>
#include "save.h"

int64 Caculate()
{
	int64 sum = 0;

	for (int32 i = 0; i < 100'000; ++i)
		sum += i;

	return sum;
}

void PromiseWorker(std::promise<string>&& promise)
{
	promise.set_value("Secret Message");
}

void TaskWorker(std::packaged_task<int64(void)>&& task)
{
	task();
}

int main()
{
	// std::future
	{
		std::future<int64> future = std::async(std::launch::async, Caculate);
		// Caculate를 위한 전용 쓰레드를 만듦

		int64 sum = future.get();
		cout << sum << endl;
	}

	// std::promise  (future를 세팅할 수 있는 객체)
	{
		// 미래(std::future)에 결과물을 반환해줄거라 약속(std::promise) 하는 것
		std::promise<string> promise;
		std::future<string> future = promise.get_future();
		// future 추출 

		thread t(PromiseWorker, std::move(promise));
		// future는 main쓰레드, promise는 Worker쓰레드가 소유함

		string message = future.get();
		cout << message << endl;
		// 데이터 추출 시 future 는 empty 상태가 됨 -> 한번만 호출할 수 있음

		t.join();
	}

	// std::packaged_task
	{
		std::packaged_task<int64(void)> task(Caculate);
		std::future<int64> future = task.get_future();

		std::thread t(TaskWorker, std::move(task));
		// 이미 존재하고 있는 쓰레드에 일감을 떠넘겨 주는 것(여러개 넘길 수 있음)

		int64 sum = future.get();
		cout << sum << endl;
		
		t.join();
	}

	// 1) async
	// 원하는 함수를 비동기적으로 실행
	// 2) promise
	// 결과물을 promise를 통해 future로 받아줌
	// 3) packkaged_task
	// 원하는 함수의 실행 결과를 packaged_task를 통해 future로 받아줌

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// 캐시
// CPU가 메모리에 접근하는 방법
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include <windows.h>
#include "save.h"

int32 buffer[10000][10000]{};

int main()
{
	{
		uint64 start = GetTickCount64();

		int64 sum = 0;
		for (int32 i = 0; i < 10000; ++i)
			for (int32 j = 0; j < 10000; ++j)
				sum += buffer[i][j];

		uint64 end = GetTickCount64();
		cout << "Elapsed Tick " << (end - start) << endl;
	}
	
	{
		uint64 start = GetTickCount64();

		int64 sum = 0;
		for (int32 i = 0; i < 10000; ++i)
			for (int32 j = 0; j < 10000; ++j)
				sum += buffer[j][i];

		uint64 end = GetTickCount64();
		cout << "Elapsed Tick " << (end - start) << endl;
	}

	// 캐시는 공간적으로 어느정도 붙어있는 메모리를 읽어와서 캐시에 저장함
	// 위의 경우는 연속적으로 데이터를 읽기 때문에 캐시의 공간적 특성상 캐시 적중할 확률이 높음
	// 아래 경우는 떨어져 있는 데이터를 읽기 때문에 캐시 미스 확률이 높음

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// CPU 파이프라인
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"

// 가시성, 코드 재배치
int32 x = 0;
int32 y = 0;
int32 r1 = 0;
int32 r2 = 0;

volatile bool ready;

void Thread_1()
{
	while (!ready)
		;

	y = 1;	// Store y
	r1 = x;	// Load x
}

void Thread_2()
{
	while (!ready)
		;

	x = 1;	// Store x
	r2 = y;	// Load y
}

int main()
{
	save("GameServer.cpp");

	int32 count = 0;

	while (true) {
		ready = false;
		count++;

		x = y = r1 = r2 = 0;

		thread t1(Thread_1);
		thread t2(Thread_2);

		ready = true;

		t1.join();
		t2.join();

		if (r1 == 0 && r2 == 0)
			break;
	}

	cout << count << " 번만에 빠져나옴 " << endl;

	// 가시성 문제
	// 멀티 쓰레드에선 코어마다 고유의 캐시를 가지고 있음
	// 따라서 공유 데이터를 사용할 때 그 값이 각각의 캐시에 저장될 수 있고 사용되기 때문에
	// 한 쓰레드가 공유 데이터의 값을 변경하여도 다른 쓰레드에서 캐시에 저장된 변경전의 데이터를 사용할 수 있다

	// 코드 재배치
	// 컴파일러/CPU 는 판단하에 작성한 코드의 위치를 수정할 수 있음
	// -> 단일 쓰레드에서 로직의 결과물이 같다는 보장이 있으면 재배치를 함
}
