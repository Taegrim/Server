------------------------------------------------------------
// Thread의 생성 및 예시
#include "pch.h"
#include <iostream>
#include "CorePch.h"

#include <thread>

void HelloThread()
{
    cout << "Hello Thread " << endl;
}

void HelloThread2(int32 num)
{
    cout << num << endl;
}

int main()
{
    std::thread t(HelloThread);
    // thread 로 HelloThread를 실행 시 독립적으로 실행 됨
    // thread는 호출가능 타입을 호출함

    cout << "Hello Main" << endl;


    //int32 count = t.hardware_concurrency(); // CPU 코어 개수가 몇개인지 알려줌
                                              // 동시에 실행 가능한 쓰레드 개수를 의미함
    //auto id = t.get_id();                   // 쓰레드마다 id를 알려줌, 쓰레드를 구분하는데 이용
                                              // 쓰레드 객체에 함수호출이 될 때 id가 할당 됨
    //t.detach();                             // thread 객체에서 실제 쓰레드를 분리
                                              // 분리 시 thread 객체의 상태, 정보 추출이 불가능
    //t.joinable();                           // 쓰레드가 연동되어 있는지를 판별
                                              // 쓰레드 객체의 생성과 함수 호출을 따로할 때 사용

    t.join();
    // join 함수로 thread 객체가 실행한 함수가 끝날때까지 기다리도록 함

    int32 count = t.hardware_concurrency();
    cout << "코어 개수 : " << count << endl;


    // 벡터에 쓰레드를 담아 이용할 경우 생성과 함수 호출을 달리하는 경우가 생김
    // ★쓰레드는 병렬로 실행되기 때문에 어느것이 먼저 호출될지는 알 수 없음
    vector<std::thread> v;

    for (int32 i = 0; i < 10; ++i)
        v.push_back(std::thread(HelloThread2, i));

    for (std::thread& th : v)
        if (th.joinable())
            th.join();

    cout << "Hello Main" << endl;
}

------------------------------------------------------------

------------------------------------------------------------
﻿// Atomic
// 공유 데이터 사용 시 발생하는 문제점들을 알아볼 것

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include "save.h"

int32 sum = 0;

void Add()
{
    for (int32 i = 0; i < 100'0000; ++i)
        ++sum;
}

void Sub()
{
    for (int32 i = 0; i < 100'0000; ++i)
        --sum;
}

int main()
{
    Add();
    Sub();
    cout << sum << endl;

    std::thread t1(Add);
    std::thread t2(Sub);

    t1.join();
    t2.join();
    cout << sum << endl;
    // thread로 공유 데이터의 덧셈, 뺄셈 수행 시 sum의 값은 할때마다 다른 값을 출력함
    // CPU 는 데이터를 변경할 때 해당 메모리의 값을 가져오고 변경한 다음 이 값을 다시 메모리에 씀
    
    // thread 2개가 덧셈 뺄셈함수를 호출할 경우 함수에서 같은 데이터를 동시에 접근한다
    // 만약 Add, Sub가 동시에 실행되면 각각 0이라는 값을 가져와서 연산을 수행한다
    // 조금이라도 더 늦은 함수의 결과에 의해 값이 써진다
    // 즉, 공유 데이터의 경우 다른 함수에서 연산이 끝나기 전에 데이터를 가져오므로 문제가 발생한다.


    save("GameServer.cpp");
}
------------------------------------------------------------

------------------------------------------------------------
﻿// Atomic
// 공유 데이터 사용 시 발생하는 문제점들을 알아볼 것

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include "save.h"

// atomic : All - Or - Nothing
// 예시 : DB
// A라는 유저 인벤에서 집행검 빼고
// B라는 유저 인벤에서 집행검을 추가
// 이 경우 한 경우만 일어나면 안되기 때문에 atomic 하게 일어나야함

// atomic을 이용하면 쓰레드간 경합이 발생하면 한 쓰레드가 데이터에 접근하면
// 다른 쓰레드는 잠시 대기하도록 함 (대기하도록 하는 주체는 CPU)
// -> 잠시 대기하도록 하기 때문에 실행 시간이 늦어지는 문제가 있음

atomic<int32> sum = 0;

void Add()
{
    for (int32 i = 0; i < 100'0000; ++i)
        sum.fetch_add(1);
        //sum++
}

void Sub()
{
    for (int32 i = 0; i < 100'0000; ++i)
        sum.fetch_add(-1);
        //--sum;
}

int main()
{
    Add();
    Sub();
    cout << sum << endl;

    std::thread t1(Add);
    std::thread t2(Sub);

    t1.join();
    t2.join();
    cout << sum << endl;

    save("GameServer.cpp");
}
------------------------------------------------------------

