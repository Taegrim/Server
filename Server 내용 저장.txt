------------------------------------------------------------
// Thread의 생성 및 예시
#include "pch.h"
#include <iostream>
#include "CorePch.h"

#include <thread>

void HelloThread()
{
    cout << "Hello Thread " << endl;
}

void HelloThread2(int32 num)
{
    cout << num << endl;
}

int main()
{
    std::thread t(HelloThread);
    // thread 로 HelloThread를 실행 시 독립적으로 실행 됨
    // thread는 호출가능 타입을 호출함

    cout << "Hello Main" << endl;


    //int32 count = t.hardware_concurrency(); // CPU 코어 개수가 몇개인지 알려줌
                                              // 동시에 실행 가능한 쓰레드 개수를 의미함
    //auto id = t.get_id();                   // 쓰레드마다 id를 알려줌, 쓰레드를 구분하는데 이용
                                              // 쓰레드 객체에 함수호출이 될 때 id가 할당 됨
    //t.detach();                             // thread 객체에서 실제 쓰레드를 분리
                                              // 분리 시 thread 객체의 상태, 정보 추출이 불가능
    //t.joinable();                           // 쓰레드가 연동되어 있는지를 판별
                                              // 쓰레드 객체의 생성과 함수 호출을 따로할 때 사용

    t.join();
    // join 함수로 thread 객체가 실행한 함수가 끝날때까지 기다리도록 함

    int32 count = t.hardware_concurrency();
    cout << "코어 개수 : " << count << endl;


    // 벡터에 쓰레드를 담아 이용할 경우 생성과 함수 호출을 달리하는 경우가 생김
    // ★쓰레드는 병렬로 실행되기 때문에 어느것이 먼저 호출될지는 알 수 없음
    vector<std::thread> v;

    for (int32 i = 0; i < 10; ++i)
        v.push_back(std::thread(HelloThread2, i));

    for (std::thread& th : v)
        if (th.joinable())
            th.join();

    cout << "Hello Main" << endl;
}

------------------------------------------------------------

------------------------------------------------------------
﻿// Atomic
// 공유 데이터 사용 시 발생하는 문제점들을 알아볼 것

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include "save.h"

int32 sum = 0;

void Add()
{
    for (int32 i = 0; i < 100'0000; ++i)
        ++sum;
}

void Sub()
{
    for (int32 i = 0; i < 100'0000; ++i)
        --sum;
}

int main()
{
    Add();
    Sub();
    cout << sum << endl;

    std::thread t1(Add);
    std::thread t2(Sub);

    t1.join();
    t2.join();
    cout << sum << endl;
    // thread로 공유 데이터의 덧셈, 뺄셈 수행 시 sum의 값은 할때마다 다른 값을 출력함
    // CPU 는 데이터를 변경할 때 해당 메모리의 값을 가져오고 변경한 다음 이 값을 다시 메모리에 씀
    
    // thread 2개가 덧셈 뺄셈함수를 호출할 경우 함수에서 같은 데이터를 동시에 접근한다
    // 만약 Add, Sub가 동시에 실행되면 각각 0이라는 값을 가져와서 연산을 수행한다
    // 조금이라도 더 늦은 함수의 결과에 의해 값이 써진다
    // 즉, 공유 데이터의 경우 다른 함수에서 연산이 끝나기 전에 데이터를 가져오므로 문제가 발생한다.


    save("GameServer.cpp");
}
------------------------------------------------------------

------------------------------------------------------------
﻿// Atomic
// 공유 데이터 사용 시 발생하는 문제점들을 알아볼 것

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include "save.h"

// atomic : All - Or - Nothing
// 예시 : DB
// A라는 유저 인벤에서 집행검 빼고
// B라는 유저 인벤에서 집행검을 추가
// 이 경우 한 경우만 일어나면 안되기 때문에 atomic 하게 일어나야함

// atomic을 이용하면 쓰레드간 경합이 발생하면 한 쓰레드가 데이터에 접근하면
// 다른 쓰레드는 잠시 대기하도록 함 (대기하도록 하는 주체는 CPU)
// -> 잠시 대기하도록 하기 때문에 실행 시간이 늦어지는 문제가 있음

atomic<int32> sum = 0;

void Add()
{
    for (int32 i = 0; i < 100'0000; ++i)
        sum.fetch_add(1);
        //sum++
}

void Sub()
{
    for (int32 i = 0; i < 100'0000; ++i)
        sum.fetch_add(-1);
        //--sum;
}

int main()
{
    Add();
    Sub();
    cout << sum << endl;

    std::thread t1(Add);
    std::thread t2(Sub);

    t1.join();
    t2.join();
    cout << sum << endl;

    save("GameServer.cpp");
}
------------------------------------------------------------

------------------------------------------------------------
﻿// Lock (mutex)
// 공유 데이터 처리 시 해결 방법

#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include "save.h"

// 벡터는 capacity가 가득차면 새로운 크기만큼 메모리를 할당하고 기존의 메모리를 삭제하는 구조
// capacity가 가득 찼을 때 쓰레드가 동시에 vector에 접근하면 나중에 실행되는 쓰레드는 삭제된 메모리를 이용함

// reserve로 용량을 확보하고 하더라도 멀티쓰레드에선 동시에 벡터에 접근할 경우
// 이전에 벡터에서 새로운 인덱스에 작성한 것을 덮어쓰는 경우가 발생함 -> 데이터의 유실 발생

vector<int32> v;

void Push()
{
	for (int32 i = 0; i < 1'0000; ++i)
		v.push_back(i);
}

int main()
{
	v.reserve(20000);

	std::thread t1(Push);
	std::thread t2(Push);
	t1.join();
	t2.join();

	cout << v.size() << endl;

   save("GameServer.cpp");
}
------------------------------------------------------------
﻿// ------------------------------------------------------------------------------------------------------------------------
// Lock (mutex)
// 공유 데이터 처리 시 해결 방법
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <mutex>
#include "save.h"

vector<int32> v;
mutex m;
// Mutual Exclusive (상호 배타적)
// atomic 처럼 딜레이가 있으므로 동작이 느림

// 유의점 1. 재귀적으로 lock 사용시 recursive_mutex 사용 (일반적인 mutex는 여러번 lock 불가능)
// 유의점 2. lock 이용 시 unlock을 반드시 해야함 (예외 처리를 할 경우 unlock이 걸리는지에 유의)
//           -> 일일히 unlock을 하면 복잡함, 빠지는 부분이 있을 수 있음 
//           -> RAII 방식으로 처리


void Push()
{
	for (int32 i = 0; i < 1'0000; ++i) {
		m.lock();
		v.push_back(i);

		m.unlock();
	}
}

int main()
{
	std::thread t1(Push);
	std::thread t2(Push);
	t1.join();
	t2.join();

	cout << v.size() << endl;

   save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Lock (mutex)
// 공유 데이터 처리 시 해결 방법
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <mutex>
#include "save.h"

vector<int32> v;
mutex m;
// Mutual Exclusive (상호 배타적)
// atomic 처럼 딜레이가 있으므로 동작이 느림

// 유의점 1. 재귀적으로 lock 사용시 recursive_mutex 사용 (일반적인 mutex는 여러번 lock 불가능)
// 유의점 2. lock 이용 시 unlock을 반드시 해야함 (예외 처리를 할 경우 unlock이 걸리는지에 유의)
//           -> 일일히 unlock을 하면 복잡함, 빠지는 부분이 있을 수 있음 
//           -> RAII 방식으로 처리
// 유의점 3. lock을 거는 범위에 따라 실행이 완전히 달라질 수 있음

// RAII (Resource Aquisition Is Initialization)

template<typename T>
class LockGuard {
public:
	LockGuard(T& m) {
		_mutex = &m;
		_mutex->lock();
	}

	~LockGuard() { _mutex->unlock(); }

private:
	T* _mutex;
};
// 객체 생성에 대한 부담이 있으나 lock, unlock을 수동으로 하는것보다 안정적임

void Push()
{
	// for문 전에 lock을 걸면 Push함수가 끝나야 다른 쓰레드가 접근할 수 있어짐
	for (int32 i = 0; i < 1'0000; ++i) {
		//LockGuard<std::mutex> lockGuard(m);
		//std::lock_guard<std::mutex> lockGuard(m);		// 표준 lock_guard

		std::unique_lock<std::mutex> uniqueLock(m, std::defer_lock);
		// std::defer_lock 으로 바로 잠그지 않고 lock() 호출 시 잠그도록 할 수 있음

		uniqueLock.lock();

		if (5000 == i)
			break;

		v.push_back(i);
	}
}

int main()
{
	std::thread t1(Push);
	std::thread t2(Push);
	t1.join();
	t2.join();

	cout << v.size() << endl;

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Dead Lock
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"
#include "AccountManager.h"
#include "UserManager.h"

void Func1()
{
	for (int32 i = 0; i < 1000; ++i)
		UserManager::Instance()->ProcessSave();
}

void Func2()
{
	for (int32 i = 0; i < 1000; ++i)
		AccountManager::Instance()->ProcessLogin();
}

int main()
{
	std::thread t1(Func1);
	std::thread t2(Func2);

	t1.join();
	t2.join();

	cout << "Done" << endl;
	// mutex가 여러개일 때 번호를 지정하여 번호에 따라 순서를 맞추면 어느정도는 해결된다

	mutex m1;
	mutex m2;

	std::lock(m1, m2);
	// std::lock을 이용하면 내부적으로 m1, m2에 순서를 부여하여 lock을 함

	lock_guard<mutex> g1(m1, std::adopt_lock);
	lock_guard<mutex> g1(m2, std::adopt_lock);
	// adopt_lock : 이미 lock된 상태니까, 나중에 소멸될 때 풀어주도록 함

	// lock을 Graph 형식으로 구성하여 사이클이 발생하는지를 추적하여 해결할 수 있음


	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Spin Lock - Lock의 구현 이론
// 
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"

// 이 SpinLock 클래스는 Lock이 되어있는지를 확인하는 부분과 Lock을 거는 부분이 분리되어 있기 때문에
// 두개 이상의 쓰레드가 동시에 사용을 하면 서로 Lock을 걸 수 있다는 문제가 있음
class SpinLock 
{
public:
	void lock() {
		// volatile 을 사용하지 않으면 컴파일러는
		// while 문의 조건이 true이므로 매번마다 while문의 조건을 체크하지 않음
		while (locked) {

		}
		locked = true;
	}

	void unlock() {
		locked = false;
	}

private:
	volatile bool locked = false;
	// volatile 은 컴파일러에게 최적화 하지 않도록 명시하는 것
};

int32 sum = 0;
mutex m;
SpinLock spinLock;

void Add()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum++;
	}
}

void Sub()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum--;
	}
}

int main()
{
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;

	save("GameServer.cpp");
}
﻿// ------------------------------------------------------------------------------------------------------------------------
// Spin Lock - Lock의 구현 이론
// 
#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include "save.h"

// SpinLock 은 두 쓰레드가 경합이 발생하면 한쓰레드는 무한히 while문을 체크함
// 따라서 다른 쓰레드가 금방 unlock을 하지 않는다면 CPU점유율이 높아진다(CPU의 낭비)는 단점이 있음
class SpinLock 
{
public:
	void lock() {
		// CAS (Compare-And-Swap) 
		bool expected = false;
		bool desired = true;

		// CAS 의사코드 - 아래 코드를 한번에 실행하는 것
		/*if (locked == expected) {
			expected = locked;
			locked = desired;
			return true;
		}
		else {
			expected = locked;
			return false;
		}*/

		while (!locked.compare_exchange_strong(expected, desired)) {
			expected = false;
		}
		locked = true;
	}

	void unlock() {
		locked.store(false);
	}

private:
	atomic<bool> locked = false;
};

int32 sum = 0;
SpinLock spinLock;

void Add()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum++;
	}
}

void Sub()
{
	for (int32 i = 0; i < 10'0000; ++i) {
		lock_guard<SpinLock>guard(spinLock);
		sum--;
	}
}

int main()
{
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	cout << sum << endl;

	save("GameServer.cpp");
}
